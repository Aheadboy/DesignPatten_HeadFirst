/**
 * 观察者模式
 * 在对象之间定义一对多的依赖
 * 当一个对象改变状态，依赖他的对象都会收到通知，并自动更新
 * <p>
 * <p>
 * Push最新的数据给所有的观察者；
 * 这样的方式，可以避免具体观察者类跟具体被观察者类的耦合；
 * 但是，Observable在状态更新后，不仅要广播更新动作，还要广播被更新的数据；
 * <p>
 * <p>
 * 通过Observer自己去pull感兴趣的数据，那么就要求Observe持有Observable的引用；这里产生了具体类之间的耦合。（这里的耦合是可以接受的）
 * 好处是：Observable不需要去广播所有更新的数据，而仅仅只是广播：我更新了。具体更新什么，Observer感兴趣什么自己来取，Observable有相应的接口来暴露观察者感兴趣的数据；
 * <p>
 * MVC是一种观察者模式，当数据更新之后，所有注册的界面都会自动更新
 * <p>
 * 实例中利用了java的Observable具体类与Observer接口
 * <p>
 * <p>
 * 网络上：
 * 观察者的两种实现方式
 * *******Push
 * <p>
 * 主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。
 * <p>
 * *******Pull
 * <p>
 * 主题对象在通知观察者的时候，只传递少量信息。
 * 如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。一般这种模型的实现中，
 * 会把主题对象自身通过update()方法传递给观察者，这样在观察者需要获取数据的时候，就可以通过这个引用来获取了。
 * <p>
 * 两种方式的比较
 * Push模型是假定主题对象知道观察者需要的数据；
 * 而Pull模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值。
 * <p>
 * Push模型可能会使得观察者对象难以复用，因为观察者的update()方法是按需要定义的参数，可能无法兼顾没有考虑到的使用情况。这就意味着出现新情况的时候，
 * 就可能提供新的update()方法，或者是干脆重新实现观察者；
 * 而Pull模型就不会造成这样的情况，
 * 因为Pull模型下，update()方法的参数是主题对象本身，这基本上是主题对象能传递的最大数据集合了，基本上可以适应各种情况的需要。
 */
package com.abu.pattern.observer;
